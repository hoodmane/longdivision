%% Package: longdivision.sty version 1.0
%% Author: Hood Chatham
%% Email: hood@mit.edu
%% Date: 2/5/2017
%% License: Latex Project Public License


\ProvidesPackage{longdivision}
\RequirePackage{xparse}

\ExplSyntaxOn


% Core registers
\bool_new:N \l__longdiv_mathmode_bool
\bool_new:N \l_longdiv_repeating_decimal_bool
\bool_new:N \l__longdiv_added_point_bool
\bool_new:N \l__longdiv_seen_point_bool
\bool_new:N \l__longdiv_seen_digit_bool
\bool_new:N \l__longdiv_stopped_early_stage_bool
\int_new:N  \l__longdiv_quotient_int
\int_new:N  \l__longdiv_position_int
\int_new:N  \l__longdiv_point_digit_dividend_int
\int_new:N  \l__longdiv_point_digit_quotient_int
\int_new:N  \l__longdiv_repeat_digit_int
\int_set:Nn \l__longdiv_repeat_digit_int { 100 }
\int_new:N  \l__longdiv_digit_group_length

\int_set:Nn \l__longdiv_digit_group_length 3

\dim_new:N \g__longdiv_temp_dim % For measuring the distance to the right side of digits

% These are used to make sure division doesn't run off the page.
\int_new:N  \l__longdiv_extra_digits_int
\int_new:N  \l__longdiv_max_extra_digits_int
\int_set:Nn \l__longdiv_max_extra_digits_int { 100 } % Infinite (just needs to be greater than max_total_digits_int and max_display_divisions_int)
\int_new:N  \l__longdiv_digits_requested_int
\int_set:Nn \l__longdiv_digits_requested_int { 100 } % Infinite (just needs to be greater than max_total_digits_int and max_display_divisions_int)

\int_const:Nn \c__longdiv_max_total_digits_int { 60 }
\int_const:Nn \c__longdiv_max_display_divisions_int { 20 }
\int_new:N \l__longdiv_display_divisions_int

\tl_new:N \l__longdiv_remainder_tl
\tl_new:N \l__longdiv_divisor_tl
\tl_new:N \l__longdiv_dividend_tl
\tl_new:N \l__longdiv_quotient_tl

% Key-value arguments
\cs_new:Npn \longdivisionkeys #1 { \keys_set:nn { longdivision } { #1 } }

\keys_define:nn { longdivision }
{
    stage .int_set:N = \l__longdiv_digits_requested_int,
    max~extra~digits .int_set:N = \l__longdiv_max_extra_digits_int,
    unknown .code:n = {
        \longdiv_if_int:nTF {\tl_use:N \l_keys_key_tl}{
            \int_set:Nn \l__longdiv_max_extra_digits_int { \l_keys_key_tl }
        }{
            \msg_error:nnx { longdivision } { unknown_key } { \tl_use:N \l_keys_key_tl }
        }
    },
    german ~ division ~ sign .code:n = {
        \cs_set:Nn \longdiv_german_division_sign: { #1 }
    },
    decimal ~ separator .code:n = {
        \cs_set:Nn \longdiv_decimal_separator: { #1 }
    },
    digit ~ separator .code:n = {
        \cs_if_exist_use:cF { longdiv_digit_separator ~ \detokenize{#1} }{
            \cs_set_protected:Nn \longdiv_digit_separator: { #1 }
        }
        %\cs_show:N \longdiv_digit_separator:
    },
    digit ~ group ~ length .int_set:N = \l__longdiv_digit_group_length,
    separators ~ in ~ work .bool_set:N = \l__longdiv_separators_in_work_bool
}

\cs_set:cpn { longdiv_digit_separator ~ _ }{
    \cs_set_protected:Nn \longdiv_digit_separator: { \texttt{\detokenize{_}} }
}

\cs_set:Nn \longdiv_decimal_separator: { . }
\cs_set:Nn \longdiv_digit_separator: { }
\bool_set_true:N \l__longdiv_separators_in_work_bool


\newcount\longdiv@tempcount
\cs_new:Npn \longdiv_if_int:nTF #1 {
    \afterassignment \longdiv_checkint_aux:w
    \longdiv@tempcount = \int_eval:w 0 #1 $$
}

\cs_new:Npn \longdiv_checkint_aux:w #1 $$ {
    \tl_if_empty:nTF { #1 }
}

\newdimen \l__longdiv_repeating_decimal_begin_dim
\newdimen \l__longdiv_repeating_decimal_end_dim
\cs_new:Nn \longdiv_register_repeating_decimal_style_choices:n {
    \keys_define:nn { longdivision } {
        repeating~decimal~style .choices:nn =
        { #1 }
        {
            \cs_set_eq:Nc \longdiv_indicate_repeating_decimal:n { longdiv_indicate_repeating_decimal_##1:n }
            \cs_if_exist:cT { longdiv_indicate_repeating_decimal_ ##1 _skip_begin: } {
                \cs_set_eq:Nc \longdiv_indicate_repeating_decimal_skip_begin: { longdiv_indicate_repeating_decimal_ ##1 _skip_begin: }
            }
            \cs_if_exist:cT { longdiv_indicate_repeating_decimal_ ##1 _skip_end: } {
                \cs_set_eq:Nc \longdiv_indicate_repeating_decimal_skip_end: { longdiv_indicate_repeating_decimal_ ##1 _skip_end: }
            }            
        }
    }
}
\cs_new:Nn \longdiv_indicate_repeating_decimal_skip_begin: { }
\cs_new:Nn \longdiv_indicate_repeating_decimal_skip_end: { }
\cs_new:Nn \longdiv_indicate_repeating_decimal_phantom:n { \longdiv_indicate_repeating_decimal_skip_begin: #1 \longdiv_indicate_repeating_decimal_skip_end: }
\cs_new:Nn \longdiv_indicate_repeating_decimal_dividend:n { \longdiv_indicate_repeating_decimal_phantom:n { #1 } }
\cs_new:Nn \longdiv_indicate_repeating_decimal_quotient:n { \longdiv_indicate_repeating_decimal:n { #1 } }

\cs_new:Nn \longdiv_register_style_choices:n {
    \keys_define:nn { longdivision } {
        style .choices:nn =
            { #1 }
            {
                \cs_set_eq:Nc \longdiv_typeset_main: { longdiv_typeset_main_##1: }
            }
    }
}

\longdiv_register_style_choices:n { default, standard, tikz, german }
\longdiv_register_repeating_decimal_style_choices:n { overline, dots, dots~all, parentheses, none }

\cs_new:Nn \longdiv_define_style:nn {
    \cs_new:cpn { longdiv_typeset_main_ #1 :} { #2 }
    \longdiv_register_style_choices:n { #1 }
}
\let \longdivdefinestyle \longdiv_define_style:nn

%%
%% Entry points
%%

\NewDocumentCommand \longdivision { omm } {
    \group_begin:
    \IfNoValueF { #1 } {
        \keys_set:nn { longdivision } { #1 }
    }
    \longdiv_start:xx { #2 } { #3 }
    \group_end:
}

% Same as \longdiv[0]{#1}{#2}.
\NewDocumentCommand \intlongdivision { omm } {
    \group_begin:
    \IfNoValueF { #1 } {
        \keys_set:nn { longdivision } { #1 }
    }
    \int_set:Nn \l__longdiv_max_extra_digits_int { 0 }
    \longdiv_start:xx { #2 } { #3 }
    \group_end:
}

\cs_generate_variant:Nn \tl_remove_all:Nn { No }

\cs_new:Nn \longdiv_start:nn {
    \tl_set:Nn \l_tmpa_tl {#1}
    \tl_set:Nn \l_tmpb_tl {#2}
    \tl_remove_all:Nn \l_tmpa_tl { ~ }
    \tl_remove_all:Nn \l_tmpb_tl { ~ }
    % \tl_if_empty:oF \longdiv_digit_separator: {
    %     \tl_remove_all:No \l_tmpa_tl { \longdiv_digit_separator: }
    %     \tl_remove_all:No \l_tmpb_tl { \longdiv_digit_separator: }
    % }
    \exp_last_unbraced:NNo \cs_set_eq:NN \longdiv_expanded_decimal_separator: \longdiv_decimal_separator:    
    \longdiv_add_leading_zero_if_necessary:N \l_tmpa_tl

    \longdiv_start_i:xx
        { \tl_use:N \l_tmpa_tl }
        { \tl_use:N \l_tmpb_tl }
}
\cs_generate_variant:Nn \longdiv_start:nn { xx }


\cs_generate_variant:Nn \tl_if_eq:nnT { xnT }
\cs_new:Nn \longdiv_add_leading_zero_if_necessary:N {
    \tl_if_eq:xnT { \tl_head:N { #1 } } { . } {
        \tl_put_left:Nn \l_tmpa_tl { 0 }
    }
}

% Check input is valid then enter main loop.
% We use \int_eval:w to ensure that the dividend has no unnecessary leading zeroes and doesn't begin with a decimal point.
% Note that \int_eval:n wouldn't work here because it inserts a "\relax" token that would not get eaten by \numexpr if
% #1 contains a decimal point. This "\relax" causes trouble for the division main loop.
\cs_new:Nn \longdiv_start_i:nn {
    \longdiv_check_dividend:n { #1 }
    \longdiv_check_divisor:n { #2 }
    \tl_set:Nn \l__longdiv_dividend_tl { #1 }
    \tl_set:Nn \l__longdiv_divisor_tl { #2 }
    \longdiv_get_new_digit:nnn { } { #2 } { #1 }
    \longdiv_break_point: { #1 } { #2 }
}
\cs_generate_variant:Nn \longdiv_start_i:nn { xx }

\cs_new_eq:NN \longdiv_break_point: \use_none:nn

%%
%% Input checkers
%%

% Parse through the dividend token by token
% Check that every token is a digit with the exception of at most one .
\cs_new:Nn \longdiv_check_dividend:n {
    \longdiv_check_dividend_before_point:N #1 \q_stop
}


\cs_new:Nn \longdiv_check_dividend_before_point:N {
    \token_if_eq_meaning:NNF #1 \q_stop {
        \token_if_eq_meaning:NNTF #1 \longdiv_expanded_decimal_separator: {
            \longdiv_check_dividend_seen_point:N
        }{
            \longdiv_check_dividend_isdigit:N #1
            \longdiv_check_dividend_before_point:N
        }
    }
}

\cs_new:Nn \longdiv_check_dividend_seen_point:N {
    \token_if_eq_meaning:NNF #1 \q_stop {
        \longdiv_check_dividend_isdigit:N #1
        \longdiv_check_dividend_seen_point:N
    }
}

\prg_new_conditional:Nnn \longdiv_if_digit:n { T, F, TF, p } {
    \bool_lazy_and:nnTF 
        { \tl_if_single_p:n { #1 } }
        {\bool_lazy_any_p:n{
            { \token_if_eq_meaning_p:NN #1 0 }
            { \token_if_eq_meaning_p:NN #1 1 }
            { \token_if_eq_meaning_p:NN #1 2 }
            { \token_if_eq_meaning_p:NN #1 3 }
            { \token_if_eq_meaning_p:NN #1 4 }
            { \token_if_eq_meaning_p:NN #1 5 }
            { \token_if_eq_meaning_p:NN #1 6 }
            { \token_if_eq_meaning_p:NN #1 7 }
            { \token_if_eq_meaning_p:NN #1 8 }
            { \token_if_eq_meaning_p:NN #1 9 }
        }}
        { \prg_return_true: }
        { \prg_return_false: }
}

\cs_new:Nn \longdiv_check_dividend_isdigit:N {
    \longdiv_if_digit:nF #1 {
        \longdiv_error:nwnn { dividend_invalid }
    }
}

% Check that there is no ., that it is at most 8 digits, and that the entire argument can get assigned to a count variable
% There's no way to do this last check in expl3, so I use plaintex \newcount, \afterassignment, and \l__longdiv_temp_int =.
\newcount \l__longdiv_temp_int
\cs_new:Nn \longdiv_check_divisor:n {
    \tl_if_in:nnT { #1 } { . } {
        \longdiv_error:nwnn { divisor_not_int }
    }
    % We have to do the length check before the "validity" check because the "validity" check makes an assignment
    % which throws a low level error if the number to be assigned is too large.
    \int_compare:nNnF { \tl_count:n { #1 } } < 9 {
        \longdiv_error:nwnn { divisor_too_large }
    }
    % Idea here: if #1 is a valid number, \l__longdiv_temp_int = 0#1 will absorb all of it.
    % So if there's any left, throw an error. Leading zero ensures that it fails on -1 and
    % that if #1 starts with some other nondigit character that it won't cause
    % "Missing number, treated as zero."
    \afterassignment \longdiv_check_divisor_aux:w
    \l__longdiv_temp_int = 0 #1 \scan_stop:
}

\cs_new:Npn \longdiv_check_divisor_aux:w #1 \scan_stop: {
    \tl_if_empty:nF { #1 } {
        \longdiv_error:nwnn { divisor_invalid }
    }
    \int_compare:nNnT \l__longdiv_temp_int = \c_zero_int {
        \longdiv_error:nwnn { divisor_zero }
    }
}

% Absorb up to break_point to gracefully quit out of the macro
\cs_new:Npn \longdiv_error:nwnn #1 #2 \longdiv_break_point: {
    \msg_error:nnnn { longdivision } { #1 }
}

% Errors:
\group_begin:
\char_set_catcode_space:N\ %
\msg_new:nnn {longdivision} {dividend_invalid} {Dividend '#1' is invalid (\msg_line_context:).}
\msg_new:nnn {longdivision} {divisor_too_large}
    {Divisor '#2' is too large (\msg_line_context:). It has \tl_count:n {#2} digits, but divisors can be at most 9 digits long.}
\msg_new:nnn {longdivision} {divisor_not_int} {Divisor '#2' is not an integer (\msg_line_context:).}
\msg_new:nnn {longdivision} {divisor_invalid} {Divisor '#2' is invalid (\msg_line_context:).}
\msg_new:nnn {longdivision} {unknown_key} {Unknown key '#1'. (\msg_line_context:).}

% Warnings:
\msg_new:nnn {longdivision} {work_stopped_early} {The work display stopped early to avoid running off the page (\msg_line_context:).}
\msg_new:nnn {longdivision} {division_stopped_early} {The division stopped early to avoid running off the page (\msg_line_context:).}
\msg_new:nnn {longdivision} {no_division_occurred}
    {Either the dividend was zero or you used \token_to_str:N \intlongdiv \space and the dividend was ~less than the divisor. ~
      This isn't a big deal, but the result probably looks silly.}
\msg_new:nnn {longdivision} {no_tikz} {You requested "style~=~tikz" but tikz has not been loaded. Falling back to "style~=~standard".}
\group_end:

%%
%% Division
%%

% #1 -- remainder
% #2 -- divisor
% #3 -- rest of digits of dividend
\cs_new:Nn \longdiv_get_new_digit:nnn {
    \tl_if_empty:nTF { #3 } { % Are we out of digits?
        % If we haven't hit the decimal point add it to the quotient and dividend
        % Set seen_digit false so that we can remove the decimal point later if it divided evenly or we used \intlongdiv
        \bool_if:NF \l__longdiv_seen_point_bool {
            \longdiv_record_point: %
            \bool_set_false:N \l__longdiv_seen_digit_bool
            \bool_set_true:N \l__longdiv_added_point_bool
        }
        \longdiv_divide_no_more_digits:nn { #1 } { #2 }
    }{
        \longdiv_get_new_digit_aux:nnw { #1 } { #2 } #3;
    }
}
\cs_generate_variant:Nn \longdiv_get_new_digit:nnn {xnn}

\cs_new:Npn \longdiv_get_new_digit_aux:nnw #1 #2 #3 #4;{
    \token_if_eq_meaning:NNTF #3 \longdiv_expanded_decimal_separator: {
        \longdiv_record_point:
        \bool_set_true:N \l__longdiv_seen_digit_bool % Prevent this decimal point from being removed later
        \bool_set_false:N \l__longdiv_added_point_bool
        \longdiv_get_new_digit:nnn { #1 } { #2 } { #4 }
    }{
        \longdiv_divide:nn { #1 #3 } { #2 } { #4 }
    }
}

% Adds a decimal point, with a leading 0 if necessary, and records the current position in \l__longdiv_point_digit_int
\cs_new:Nn \longdiv_record_point: {
    \bool_if:NF \l__longdiv_seen_digit_bool {
        \tl_put_right:Nn \l__longdiv_quotient_tl { 0 } % Add a leading zero
    }
    \int_set_eq:NN \l__longdiv_point_digit_dividend_int { \l__longdiv_position_int } % Record the position of the point
    \bool_set_true:N \l__longdiv_seen_point_bool
    \int_set:Nn \l__longdiv_point_digit_quotient_int { \tl_count:N \l__longdiv_quotient_tl }
}

% Divide when we still have more digits.
% #1 -- thing to divide
% #2 -- divisor
% Finds the quotient, adds it to the linked list and to the work token list then recurses.
\cs_new:Nn \longdiv_divide:nn {
    \int_compare:nNnTF \l__longdiv_position_int = \l__longdiv_digits_requested_int {
        \longdiv_divide_end_early:nnn { #1 } { #2 }
    }{
        \int_set:Nn \l__longdiv_quotient_int { \int_div_truncate:nn { #1 } { #2 } }
        \bool_if:nTF {
            \int_compare_p:nNn \l__longdiv_quotient_int = \c_zero_int % If the quotient was zero, we might not have to print it
            && !\l__longdiv_seen_digit_bool % If no other digits have been printed
            && !\l__longdiv_seen_point_bool % And we are before the decimal point
        }{
            \int_incr:N \l__longdiv_digits_requested_int % Get an extra digit, this one doesn't count.
        }{ % Otherwise print it and record that we've seen a digit (all further 0's must be printed)
            \bool_set_true:N \l__longdiv_seen_digit_bool
            \tl_put_right:Nf \l__longdiv_quotient_tl { \int_use:N \l__longdiv_quotient_int }
        }
        \int_incr:N \l__longdiv_position_int
        \longdiv_divide_record:nn { #1 }{ #2 }
        \longdiv_get_new_digit:xnn { \longdiv_remainder:nn { #1 } { #2 } } { #2 }
    }
}

\cs_generate_variant:Nn \tl_reverse:n {f}

% Called if we stop early due to \l__longdiv_digits_requested_int.
% #1 -- thing to divide
% #2 -- divisor
% #3 -- rest of digits of dividend
% If we stop early, we have to pad the quotient with the extra length of the dividend
% because the top bar of the division symbol uses the length of the quotient to determine
% the length of the bar, but we need it to always be at least as long as the dividend.
% Also, we need to delete the extra digit that has been carried down
\cs_new:Nn \longdiv_divide_end_early:nnn {
    % For some reason we need to shift the typeset work over by half a digit if we quit early due to "stage" option
    % so we need to set a flag so that the work typesetter can know to do this.
    \bool_set_true:N \l__longdiv_stopped_early_stage_bool
    \tl_put_right:Nn \l__longdiv_quotient_tl { {\longdiv_hphantom:n { #3 0 }} }
    \tl_set:Nf \l__longdiv_remainer { \tl_range:nnn  { #1 } { 1 } { -2 } } 
    \longdiv_typeset:
}

% \relax to protect also against f expansion
\cs_new:Nn \longdiv_hphantom:n { \relax \longdiv_hphantom_aux: { #1 } }
\cs_new_protected:Nn \longdiv_hphantom_aux: { \hphantom }

% Divide when we are out of digits.
% #1 -- remainder from last time (we will add a zero to the end)
% #2 -- divisor
% This case is more complicated because we have to check for repeated remainders, and whether to stop
% though we are certainly after the decimal point so we don't need to check whether we need to print 0's.
\cs_new:Nn \longdiv_divide_no_more_digits:nn {
    % If we've seen this remainder before, we're done. Use the appropriate command
    % to insert the overline, and then typeset everything
    \cs_if_exist_use:cTF { longdiv_remainders ~ \int_eval:n { #1 } }{ % \int_eval:n to remove leading zero
        \tl_set:Nn \l__longdiv_remainder_tl { #1 }
        \longdiv_typeset:  
    }{
        \bool_if:nTF {
              \int_compare_p:nNn \l__longdiv_extra_digits_int = \l__longdiv_max_extra_digits_int
            ||\int_compare_p:nNn \l__longdiv_position_int = \c__longdiv_max_total_digits_int
            ||\int_compare_p:nNn \l__longdiv_position_int = \l__longdiv_digits_requested_int
        }{
            \int_compare:nNnT \l__longdiv_position_int = \c__longdiv_max_total_digits_int {
                \msg_warning:nn { longdivision } { division_stopped_early }
            }
            \tl_set:Nn \l__longdiv_remainder_tl { #1 }
            \longdiv_typeset:
        }{
            % Otherwise, record that we've seen this remainder and the position we're in
            % In case this is the first digit of the repeated part
            \cs_set:cpx { longdiv_remainders ~ \int_eval:n { #1 } }{ % \int_eval:n to remove leading zero
                \exp_not:N \int_set:Nn \exp_not:N \l__longdiv_repeat_digit_int { 
                    \tl_count:N \l__longdiv_quotient_tl - \int_use:N \l__longdiv_point_digit_quotient_int
                }
            }
            % Now we have to use #1 0 everywhere
            \int_set:Nn \l__longdiv_quotient_int { \int_div_truncate:nn { #1 0 } { #2 } }
            \tl_put_right:Nf \l__longdiv_quotient_tl { \int_use:N \l__longdiv_quotient_int }
            \bool_set_true:N \l__longdiv_seen_digit_bool % We've seen a digit after the decimal point, don't need to remove it
            \int_incr:N \l__longdiv_position_int
            \int_incr:N \l__longdiv_extra_digits_int
            \longdiv_divide_record:nn { #1 0 } { #2 }
            \longdiv_divide_no_more_digits:xn { \longdiv_remainder:nn { #1 0 } { #2 } } { #2 }
        }
    }
}
\cs_generate_variant:Nn \longdiv_divide_no_more_digits:nn { xn }

% Whenever we see the remainder 0, we're done, and we don't have to put an overline.
\cs_new:cpn { longdiv_remainders ~ 0 }{}

% This command checks if the quotient was zero, and if so preserves the leading zero by avoiding \int_eval:n
% This is so that e.g, \longdiv{14.1}{7} doesn't screw up
\cs_new:Nn \longdiv_remainder:nn {
    \int_compare:nNnTF \l__longdiv_quotient_int = \c_zero_int
        { #1 }
        { \int_eval:n { #1 - \l__longdiv_quotient_int * #2 } }
}


% We're going to store the "work" for the long division in this tl as a series of triples:
% #1 -- number of digits we've processed so far (for positioning subtractions and determining if point should be added)
% #2 -- old remainder (thing to subtract from)
% #3 -- quotient * divisor (thing to subtract)
\tl_new:N \l__longdiv_work_tl
\cs_new:Nn \longdiv_divide_record:nn {
    \int_compare:nNnTF \l__longdiv_display_divisions_int < \c__longdiv_max_display_divisions_int {
        \int_compare:nNnF \l__longdiv_quotient_int = \c_zero_int { % If the quotient was zero, nothing needs to be typeset
            \tl_set:Nx \l__longdiv_work_tl {
                \l__longdiv_work_tl
                    { \int_use:N \l__longdiv_position_int } { #1 } { \int_eval:n { \l__longdiv_quotient_int * #2 } }
            }
            \int_incr:N \l__longdiv_display_divisions_int
        }
    }{
        \int_compare:nNnT \l__longdiv_display_divisions_int = \c__longdiv_max_display_divisions_int {
            \int_compare:nNnF \l__longdiv_quotient_int = \c_zero_int {
                \tl_set:Nx \l__longdiv_work_tl {
                    \l__longdiv_work_tl
                        { \int_use:N \l__longdiv_position_int } { #1 } { \int_eval:n { \l__longdiv_quotient_int * #2 } }
                        \exp_not:N \longdiv_typeset_work_last:nn { \int_use:N \l__longdiv_position_int } { \int_eval:n { #1 - \l__longdiv_quotient_int * #2 } }
                }
                \int_incr:N \l__longdiv_display_divisions_int
                \msg_warning:nn { longdivision } { work_stopped_early }
            }
        }
    }
}

%%
%% Typesetting
%%

\cs_new_protected:Nn \longdiv_return_to_original_mode:n { \bool_if:NF \l__longdiv_mathmode_bool \hbox { #1 } }

%% Indicate repeating decimals
% These are all different implementations of \longdiv_indicate_repeating_decimal:n
% They take one input which is the index of the start of the repeating decimal in the linked list

% Chosen using "repeating decimal style", default is "dots all"
% possible values: "overline", "dots", "dots all", "parentheses"

% Put an \overline over the repeated digits. \overline only works in math mode, so we have to use \ensuremath. Then we put an \hbox
% to take ourselves
\cs_new:Nn \longdiv_indicate_repeating_decimal_overline:n {
    \longdiv_ensuremath:n { \overline { \longdiv_return_to_original_mode:n {  
        #1
    } } }
}

\cs_new_protected:Nn \longdiv_dot:n { 
    \longdiv_if_digit:nTF { #1 } {
        \longdiv_ensuremath:n { \dot { \longdiv_return_to_original_mode:n { #1 } } } 
    }{
        #1
    }
}

\cs_new:cn { longdiv_indicate_repeating_decimal_dots~all:n } {
    \tl_map_function:nN { #1 } \longdiv_dot:n % \tl_map_function is expandable whereas \tl_map_inline is not.
}


\cs_new:Nn \longdiv_indicate_repeating_decimal_dots:n {
    \longdiv_dot:n { \tl_head:n { #1 } }
    \expanded { \tl_range:nnn { #1 } { 2 } { -2 } }
    \longdiv_dot:n { \tl_item:nn { #1 } { -1 } }
}

\bool_new:N \l__longdiv_repeating_decimal_parentheses_bool


\cs_new:Nn \longdiv_indicate_repeating_decimal_parentheses:n {
    (#1)
}

\cs_new:Nn \longdiv_indicate_repeating_decimal_parentheses_skip_begin: {
    { \longdiv_hphantom:n { ( } }
}

\cs_new:Nn \longdiv_indicate_repeating_decimal_parentheses_skip_end: {
    { \longdiv_hphantom:n { ) } }
}


% Do nothing, don't indicate repeating digits at all.
\cs_new:Nn \longdiv_indicate_repeating_decimal_none:n { #1 }

% Default is overline
\cs_new_eq:NN \longdiv_indicate_repeating_decimal:n \longdiv_indicate_repeating_decimal_overline:n

\cs_new:Nn \longdiv_undefine_markers: {
    \cs_undefine:N \longdiv_decimal_separator_marker:
    \cs_undefine:N \longdiv_digit_separator_marker:
    \cs_undefine:N \longdiv_repeat_marker:
}

\cs_new:Nn \longdiv_typeset_work: { 
    \bool_if:NTF \l__longdiv_separators_in_work_bool {
        \cs_gset_eq:NN \longdiv_decimal_separator_marker: \longdiv_decimal_separator:
        \cs_gset_eq:NN \longdiv_digit_separator_marker: \longdiv_digit_separator:
    }{
        \cs_gset:Nn \longdiv_decimal_separator_marker: {{ \longdiv_hphantom:n { \longdiv_decimal_separator: } }}
        \cs_gset:Nn \longdiv_digit_separator_marker: {{  \longdiv_hphantom:n { \longdiv_digit_separator: } }}
    }
    \cs_gset:Nn \longdiv_repeat_marker: { \longdiv_indicate_repeating_decimal_skip_begin: }
    \longdiv_typeset_work:n { \tl_use:N \l__longdiv_remainder_tl }
    \longdiv_undefine_markers:
}

\cs_new:Nn \longdiv_typeset_divisor: {
    \longdiv_typeset_number:n { \tl_use:N \l__longdiv_divisor_tl } 
}

\cs_new:Nn \longdiv_typeset_dividend: { 
    \longdiv_typeset_number:n { \tl_use:N \l__longdiv_dividend_tl } 
}

\cs_set:Npn \longdiv_typeset_quotient: { 
    \longdiv_typeset_number:n { \tl_use:N \l__longdiv_quotient_tl } 
}

\cs_set:Npn \longdiv_typeset_remainder: {  % This isn't used in current typesetting code, just could be nice to have
    \longdiv_typeset_number:n { \tl_use:N \l__longdiv_remainder_tl } 
}

% At this point, the divisor, dividend, quotient, and remainder should all be stored in their appropriate token lists:
% \l__longdiv_divisor_tl 
% \l__longdiv_dividend_tl 
% \l__longdiv_quotient_tl 
% \l__longdiv_remainder_tl 
% Of course we also care about all sorts of other state...
\cs_new:Nn \longdiv_typeset: {
    \tl_set:Nx \l__longdiv_dividend_tl { 
        \tl_use:N \l__longdiv_dividend_tl
        \bool_if:NT \l__longdiv_seen_digit_bool { % we don't want to add a trailing decimal point to the dividend if it divided evenly
            \longdiv_typeset_extra_zeroes:
        }
    }

    \mode_if_math:TF { \bool_set_true:N \l__longdiv_mathmode_bool } { \bool_set_false:N \l__longdiv_mathmode_bool }
    \bool_set:Nn \l_longdiv_repeating_decimal_bool { \int_compare_p:nNn \l__longdiv_repeat_digit_int < { 100 } }
    
    \longdiv_insert_separators_into_tl:Nn \l__longdiv_divisor_tl { \tl_count:N \l__longdiv_divisor_tl }
    \longdiv_prepare_dividend:
    \longdiv_prepare_quotient:

    \let\longdivwork\longdiv_typeset_work:
    \let\longdivdivisor\longdiv_typeset_divisor:
    \let\longdivdividend\longdiv_typeset_dividend:
    \let\longdivquotient\longdiv_typeset_quotient:
    \let\longdivremainder\longdiv_typeset_remainder:
    \longdiv_typeset_main:
}

\cs_new:Nn \longdiv_prepare_quotient: {
    \longdiv_insert_separators_into_tl:Nn \l__longdiv_quotient_tl { \l__longdiv_point_digit_quotient_int }
    \cs_set:Nn \longdiv_decimal_separator_marker: { { \longdiv_smash:n { \longdiv_decimal_separator: } } } 
    \cs_set:Nn \longdiv_digit_separator_marker: { { \longdiv_smash:n { \longdiv_digit_separator: } } }
    \cs_set:Npn \longdiv_repeat_marker: ##1 \s_stop {
        \longdiv_indicate_repeating_decimal_quotient:n { ##1 }
    }
    \tl_set:Nx \l__longdiv_quotient_tl { \tl_use:N \l__longdiv_quotient_tl \s_stop }
    \longdiv_undefine_markers:
}

\cs_new_protected:Nn \longdiv_smash:n {  { #1 } }

\cs_new:Nn \longdiv_prepare_dividend: {
    \tl_remove_all:No \l__longdiv_dividend_tl { \longdiv_decimal_separator: }    
    \longdiv_insert_separators_into_tl:Nn \l__longdiv_dividend_tl { \l__longdiv_point_digit_dividend_int }
    % In the tikz output, commas seem to lift the entire number being printed.
    % There is probably some tikz baseline option that fixes this
    \cs_set:Nn \longdiv_decimal_separator_marker: { { \longdiv_smash:n { \longdiv_decimal_separator: } } } 
    \cs_set:Nn \longdiv_digit_separator_marker: { { \longdiv_smash:n { \longdiv_digit_separator: } } }
    \cs_set:Npn \longdiv_repeat_marker: ##1 \s_stop {
        \longdiv_indicate_repeating_decimal_dividend:n { ##1 }
    }
    \tl_set:Nx \l__longdiv_dividend_tl { \tl_use:N \l__longdiv_dividend_tl \s_stop }
    \tl_build_clear:N \l_tmpa_tl
    \tl_build_clear:N \l_tmpb_tl
    \tl_map_inline:Nn \l__longdiv_dividend_tl {
        \tl_build_put_right:Nn \l_tmpb_tl { ##1 }
        \longdiv_if_digit:nT { ##1 } {
            \tl_build_end:N \l_tmpb_tl
            \tl_build_put_right:No \l_tmpa_tl {
                \exp_after:wN { \exp:w \exp_end_continue_f:w \tl_use:N \l_tmpb_tl }
            }
            \tl_build_clear:N \l_tmpb_tl
        }
    }
    % Catch any trailing punctuation
    \tl_build_end:N \l_tmpb_tl
    \tl_build_put_right:No \l_tmpa_tl {
        \exp_after:wN { \exp:w \exp_end_continue_f:w \tl_use:N \l_tmpb_tl }
    }
    \tl_build_end:N \l_tmpa_tl
    \tl_set_eq:NN \l__longdiv_dividend_tl \l_tmpa_tl
    \longdiv_undefine_markers:
}

\int_new:N \l__longdiv_temp_length_int

\cs_generate_variant:Nn \tl_map_inline:nn { fn }
\cs_generate_variant:Nn \tl_put_right:Nn { Nf }
\cs_generate_variant:Nn \tl_build_put_right:Nn { No, Nf }

\cs_new:Nn \longdiv_insert_separators_into_tl:Nn {
    \int_set:Nn \l_tmpa_int { - \int_eval:n { #2 } + 1 }
    \tl_build_clear:N \l_tmpa_tl
    \tl_build_put_right:Nf \l_tmpa_tl { \tl_head:N #1 }    
    \tl_map_inline:fn { \tl_tail:N #1 } {

        \int_compare:nNnTF \l_tmpa_int = 0  {
            \tl_build_put_right:Nn \l_tmpa_tl { \longdiv_decimal_separator_marker: }
        }{
            % Check if \l_tmpa_int is divisible by \l__longdiv_digit_group_length.
            \int_compare:nNnT \l_tmpa_int = { \l_tmpa_int / \l__longdiv_digit_group_length * \l__longdiv_digit_group_length } { 
                \tl_build_put_right:Nn \l_tmpa_tl { \longdiv_digit_separator_marker: } 
            }
        }
        \int_compare:nNnT \l_tmpa_int = \l__longdiv_repeat_digit_int {
            \tl_build_put_right:Nn \l_tmpa_tl { \longdiv_repeat_marker: }
        }
        \tl_build_put_right:Nn \l_tmpa_tl { ##1 }
        \int_incr:N \l_tmpa_int
    }
    \tl_build_get:NN \l_tmpa_tl #1
}





\cs_new:Nn \longdiv_typeset_extra_zeroes: {
    \prg_replicate:nn { \l__longdiv_extra_digits_int } { 0 }
}

\cs_new:Nn \longdiv_typeset_main_default: {
    \bool_if:NTF \l__longdiv_is_tikz_loaded_bool {
        \longdiv_typeset_main_tikz:
    } {
        \longdiv_typeset_main_standard:
    }
}
\cs_new_eq:NN \longdiv_typeset_main: \longdiv_typeset_main_default:


\longdiv_define_style:nn { standard } {
    \hskip4pt
    \rule{0pt}{22pt} \longdiv_typeset_divisor: \, \begin{tabular}[b]{@{}r@{}}
        \longdiv_typeset_quotient: \,
        \\\hline

    \smash{\big)}\begin{tabular}[t]{@{}l@{}}
    \longdiv_typeset_dividend:{\hskip 3pt}\relax \\
    \longdiv_typeset_work:\\[3pt]
    \end{tabular}\,
    \end{tabular}
    \hskip5.3pt
}

\bool_new:N \l__longdiv_is_tikz_loaded_bool
\AtBeginDocument{ \@ifpackageloaded { tikz }{ \bool_gset_true:N \l__longdiv_is_tikz_loaded_bool } { } }

\cs_new:Nn \longdiv_german_division_sign: { : }

\longdiv_define_style:nn { german } {
    \begin{tabular}[t]{@{}l@{}}
    \longdiv_typeset_dividend: \hskip1pt \longdiv_german_division_sign: \hskip1pt \longdiv_typeset_divisor: \hskip4pt = \hskip4pt \longdiv_typeset_quotient: \\
    \longdiv_typeset_work:
    \end{tabular}
}


\newlength{\longdiv@dividendlength}
\newlength{\longdiv@dividendheight}
\newlength{\longdiv@divisorheight}
\newlength{\longdiv@maxheight}


\let\longdiv@ifl@aded\@ifl@aded
\let\longdiv@pkgextension\@pkgextension
\def\longdiv@ifpackageloaded{\@ifl@aded\@pkgextension}

\longdiv_define_style:nn { tikz }{
    \let\@ifl@aded\longdiv@ifl@aded
    \let\@pkgextension \longdiv@pkgextension
    \bool_if:NTF \l__longdiv_is_tikz_loaded_bool {
        \longdiv@typeset@main@tikz
    } {
        \msg_warning:nn { longdivision } { no_tikz }
        \longdiv_typeset_main_standard:
    }
}

\ExplSyntaxOff
\def\longdiv@typeset@main@tikz{
    \settowidth{\longdiv@dividendlength}{1.\longdivdividend}
    \settoheight{\longdiv@dividendheight}{\longdivdividend}
    \settoheight{\longdiv@maxheight}{\longdivdividend\longdivdivisor}
    \settoheight{\longdiv@divisorheight}{\longdivdivisor}
    \begin{tikzpicture} [baseline=.5pt, text height=\longdiv@maxheight]
        \draw (1pt,.5*\longdiv@divisorheight)  
            node [left, text depth=0pt] { \longdivdivisor };
        \draw (\longdiv@dividendlength,.5*\longdiv@dividendheight ) 
            node [left, text depth=0pt] { \longdivdividend };
        \draw [line width=0.2mm]  
            (0pt,-.22*\longdiv@dividendheight) arc (-70:60:\longdiv@maxheight*.41 and \longdiv@maxheight*.88) 
            -- ++(\longdiv@dividendlength-2pt, 0pt);
        \draw (\longdiv@dividendlength,\longdiv@divisorheight+\longdiv@maxheight*.37) 
            node[above left, text depth=0pt] { \longdivquotient };
        \draw (1pt,0) node[below right] {
            \begin{tabular}[t]{@{}l@{}}
            \longdivwork
            \end{tabular}
        };
    \end{tikzpicture}
}
\ExplSyntaxOn

\cs_new_protected:Nn \longdiv_ensuremath:n { \ensuremath{#1} }

\cs_new_protected:Nn \longdiv_typeset_number:n {
    \bool_if:NTF \l__longdiv_mathmode_bool { \longdiv_ensuremath:n { #1 } } { \hbox { #1 } }
}


% Iterate through the division "work" and typeset it
% Argument is remainder at end
\cs_new:Nn \longdiv_typeset_work:n {
    \tl_if_empty:NTF \l__longdiv_work_tl {
        \msg_warning:nn { longdivision } { no_division_occurred }
    }{
        \exp_after:wN \longdiv_typeset_work_first:nnn \l__longdiv_work_tl
        \int_compare:nNnT \l__longdiv_display_divisions_int < \c__longdiv_max_display_divisions_int {
            \exp_args:No \longdiv_typeset_work_last:nn { \int_use:N \l__longdiv_position_int } { #1 }
        }
    }
}

\cs_new:Nn \longdiv_llap_preserve_math_mode:n {
    \if_mode_math:
        \llap{$#1$}
    \else
        \llap{#1}
    \fi
}

\tl_new:N \g__longdiv_work_line_tl

\cs_new:Nn \longdiv_work_insert_separators:Nn {
    \longdiv_insert_separators_into_tl:Nn #1 { \l__longdiv_point_digit_dividend_int  + \tl_count:N #1 - #2  }
}

% #1 -- digits in to the right side of the numbers we are writing
% #2 -- remainder from last time with new digits added to the right
% #3 -- quotient * divisor
% _first only typesets quotient * divisor and the line
% _rest typesets result from last time, quotient * divisor and the line
% _last only typesets the remainder from last time
\cs_new:Nn \longdiv_typeset_work_first:nnn {
    \longdiv_typeset_setwidth:n { #1  }
    \hspace{\g__longdiv_temp_dim}
    \tl_gset:Nf \g__longdiv_work_line_tl { #3 }
    \longdiv_work_insert_separators:Nn { \g__longdiv_work_line_tl } { #1 }
    \tl_gset_eq:NN \g__longdiv_work_line_tl \g__longdiv_work_line_tl
    \longdiv_llap_preserve_math_mode:n { \longdiv_typeset_number:n { \g__longdiv_work_line_tl } }
    \\\longdiv_rule:N { \g__longdiv_work_line_tl }
    \peek_meaning:NT \bgroup {
        \longdiv_typeset_work_rest:nnn
    }
}

\cs_new:Nn \longdiv_typeset_work_rest:nnn {
    \longdiv_typeset_setwidth:n { #1 }
    \hspace{\g__longdiv_temp_dim}
    \tl_gset:Nf \g__longdiv_work_line_tl { #2 }
    \longdiv_work_insert_separators:Nn { \g__longdiv_work_line_tl } { #1 }
    \tl_gset_eq:NN \g__longdiv_work_line_tl \g__longdiv_work_line_tl
    \longdiv_llap_preserve_math_mode:n { \longdiv_typeset_number:n { \g__longdiv_work_line_tl } }
    \\
    \hspace{\g__longdiv_temp_dim}
    \tl_gset:Nf \g__longdiv_work_line_tl { #3 }
    \longdiv_work_insert_separators:Nn { \g__longdiv_work_line_tl } { #1 }
    \tl_gset_eq:NN \g__longdiv_work_line_tl \g__longdiv_work_line_tl
    \longdiv_llap_preserve_math_mode:n { \longdiv_typeset_number:n { \g__longdiv_work_line_tl } }
    \\\longdiv_rule:N { \g__longdiv_work_line_tl }
    \peek_meaning:NT \bgroup {
        \longdiv_typeset_work_rest:nnn
    }
}

% #1 -- digits in to the right side of the numbers we are writing
% #2 -- remainder from last time with new digits added to the right
\cs_new:Nn \longdiv_typeset_work_last:nn {
    \longdiv_typeset_setwidth:n { #1 }
    \hspace{\g__longdiv_temp_dim}
    \tl_gset:Nf \g__longdiv_work_line_tl { #2 }
    \longdiv_work_insert_separators:Nn { \g__longdiv_work_line_tl } { #1 }
    \tl_gset_eq:NN \g__longdiv_work_line_tl \g__longdiv_work_line_tl
    \longdiv_llap_preserve_math_mode:n { \longdiv_typeset_number:n { \g__longdiv_work_line_tl } }
}

% Set \g__longdiv_temp_dim equal to digitwidth * number of digits
% If we are past the decimal point, add  \c__longdiv_pointwidth_dim
\cs_new:Nn \longdiv_typeset_setwidth:n {
    \settowidth \l__longdiv_tempwidth_dim {\tl_range:Nnn \l__longdiv_dividend_tl { 1 } { #1 } \relax }
    \dim_gset:Nn \g__longdiv_temp_dim { \l__longdiv_tempwidth_dim }
    % For some reason we need to shift everything over by half a digit if we quit early due to "stage" option
    \bool_if:NT \l__longdiv_stopped_early_stage_bool {\dim_gadd:Nn \g__longdiv_temp_dim { -0.5\c__longdiv_digitwidth_dim } }
}

% Okay, this is another section where we are adulterated with plaintex stuff.
% It would be easy to reimplement \settowidth, but \hrule and \noalign have no
% expl3 name anyways. Since I only use these dim variables with \settowidth, I declare
% them with \newdimen rather than \dim_new:N
% \newdimen   \c__longdiv_digitwidth_dim
% \settowidth \c__longdiv_digitwidth_dim { 0 }
% \newdimen   \c__longdiv_pointwidth_dim
% \settowidth \c__longdiv_pointwidth_dim { . }
\newdimen   \c__longdiv_parenwidth_dim
\settowidth \c__longdiv_parenwidth_dim { ( }

\newdimen  \l__longdiv_tempwidth_dim
\newdimen \l__longdiv_rulethickness_dim
\l__longdiv_rulethickness_dim = 0.2mm

\cs_new:Nn \longdiv_rule:N {
    \noalign {
        \settowidth \l__longdiv_tempwidth_dim { \tl_use:N #1 }
        \box_move_right:nn { \g__longdiv_temp_dim - \l__longdiv_tempwidth_dim } {
            \vbox:n { \hrule width \l__longdiv_tempwidth_dim height \l__longdiv_rulethickness_dim }
        }
    }
}

\ExplSyntaxOff
